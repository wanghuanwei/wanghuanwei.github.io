<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="萧易的技术沉淀">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="萧易的技术沉淀">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="萧易的技术沉淀">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '萧易'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>萧易的技术沉淀</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">萧易的技术沉淀</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/14/Redis源码解析(二)-跳跃表/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="萧易">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/14055251?s=400&u=add42f8954fab30e11d0ecfdbc130b25da161103&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="萧易的技术沉淀">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/14/Redis源码解析(二)-跳跃表/" itemprop="url">Redis源码解析(二)-跳跃表</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-14T11:00:00+08:00">
                2019-07-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>今天的主题是跳跃表，不知道算不算是Redis中特有的一个数据结构，但就我自己而言，第一次见到跳跃表这种数据结构，确实是在Redis中。相较于平衡二叉树，红黑树而言，跳跃表的查询性能也并不差，但是这是就平均而言，查询性能都是O(logN)。最不理想的情况下，跳跃表的查询性能为O(N)。但跳跃表有个很大的优势，不需要旋转。每次红黑树进行操作后，都会进行一次自旋，而跳跃表完全不需要这个操作，所以在写的时候，性能要高很多。<br>来个跳跃表的示例图：<img src="/2019/07/14/Redis源码解析(二)-跳跃表/Redis源码解析(二" alt="跳跃示例">-跳跃表/skiplist.png)</p>
<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>跳跃表的查询，是通过插入就可以看出来是怎么操作的。<br>在插入时，跳跃表会先进行查询，查询到需要插入的位置，然后再执行插入操作。</p>
<p>跳跃表每插入一个节点，都会给节点随机一个level，指定节点的层级，level的范围是1-64</p>
<pre><code>
int zslRandomLevel(void) {
    int level = 1;
    while ((random()&0xFFFF) < (ZSKIPLIST_P * 0xFFFF))
        level += 1;
    return (level<zskiplist_maxlevel) ? level : zskiplist_maxlevel; }< code></zskiplist_maxlevel)></code></pre>

<p>随机时，是幂次定律（如果某件事的发生频率和它的某个属性成幂关系，那么这个频率就可以称之为符合幂次定律），每循环一次，level增加1，但增加的次数不会无线增加，随机出来的小于0xFFFF的数（(random()&amp;0xFFFF)） 还要小于0xFFFF * 0.25 这样，每循环一次，下次进行循环的概率就会变小。<br>具体算法可以参考：<a href="https://mcgrady-forever.github.io/2018/02/05/redis-analysis-skiplist" target="_blank" rel="noopener">https://mcgrady-forever.github.io/2018/02/05/redis-analysis-skiplist</a></p>
<p>插入时，会先找到每一层的最小大于当前插入score的节点到update[]中，并保存对应的跨越的长度</p>
<pre><code>
    x = zsl->header;
    for (i = zsl->level-1; i >= 0; i--) {
        /* store rank that is crossed to reach the insert position */
        rank[i] = i == (zsl->level-1) ? 0 : rank[i+1];  // 记录每一层的跨度
        while (x->level[i].forward &&
                (x->level[i].forward->score < score ||
                    (x->level[i].forward->score == score &&
                    sdscmp(x->level[i].forward->ele,ele) < 0)))   // 查找第一个不小于插入score的节点
        {
            rank[i] += x->level[i].span;
            x = x->level[i].forward;
        }
        update[i] = x;  // i层指向最小大于插入score的节点
    }
</code></pre>

<p>找到对应的地址后，获取当前插入节点的随机level值：</p>
<pre><code>
    level = zslRandomLevel();
    if (level > zsl->level) {
        for (i = zsl->level; i < level; i++) {
            rank[i] = 0;
            update[i] = zsl->header;
            update[i]->level[i].span = zsl->length;
        }
        zsl->level = level;
    }
</code></pre>

<p>如果获取的level大于当前zskiplist的level，会进行升层，并且最大层直接指向新插入的节点</p>
<p>然后循环处理每一层的数据，插入当前节点</p>
<pre><code>
    for (i = 0; i < level; i++) {
        x->level[i].forward = update[i]->level[i].forward;
        update[i]->level[i].forward = x;

        // 更新对应的跨度
        x->level[i].span = update[i]->level[i].span - (rank[0] - rank[i]);
        update[i]->level[i].span = (rank[0] - rank[i]) + 1;
    }

    // 每一层的总跨度都加1
    for (i = level; i < zsl->level; i++) {
        update[i]->level[i].span++;
    }
</code></pre>

<p>可以参考下图：<br><img src="/2019/07/14/Redis源码解析(二)-跳跃表/Redis源码解析(二" alt="跳跃插入">-跳跃表/insert.png)</p>
<h4 id="更新score"><a href="#更新score" class="headerlink" title="更新score"></a>更新score</h4><p>跳跃表在Redis中，是结合字典构成了zset的底层存储结构（在zset数据量较少时，会使用ziplist数据结构，当数量超过一定值后，切换成字典+跳跃表的形式），所以跳跃表都是有序的，按照score值进行由小到大的排序。<br>而zset中，每个节点都有一个score值，用来排序。所以当一个节点的score被更新时，就有可能会涉及到跳跃表的重排序<br>具体步骤如下：</p>
<ol>
<li>查找到需要更新的节点</li>
<li>更新score值，并判断是否需要重新排序</li>
<li>如果需要时，则删除当前节点， 并用新的score值生成新的节点并插入当前的结构中</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/26/Redis源码解析（一）-字典/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="萧易">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/14055251?s=400&u=add42f8954fab30e11d0ecfdbc130b25da161103&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="萧易的技术沉淀">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/26/Redis源码解析（一）-字典/" itemprop="url">Redis源码解析（一）:字典</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-26T21:46:00+08:00">
                2019-06-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="前面说的"><a href="#前面说的" class="headerlink" title="前面说的"></a>前面说的</h4><p>作为在当前互联网环境中最受欢迎的缓存服务，Redids一直受到各大公司的欢迎。今天开始就专门写一个Redis的相关系列。<br>Redis是完全开源的一个系统，源码是C语言，本系列也是基于3.2的版本来写。</p>
<h4 id="字典简介"><a href="#字典简介" class="headerlink" title="字典简介"></a>字典简介</h4><p>字典这个Redis的底层数据结构，是Redis非常重要的一个数据结构，基本上所有的Redis支持的对象都依赖了字典这一数据结构。<br>说到这，不得不先插播一条额外的东西，Redis中支持5中对象类型，分别是：字符串、列表、哈希、集合、有序集合。而每种对象会有不同的底层数据结构，对应redis命令的话，就是type和encoding。其中对象和数据结构的对应关系如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">对象</th>
<th style="text-align:center">数据结构</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">字符串</td>
<td style="text-align:center">简单动态字符串（SDS）</td>
</tr>
<tr>
<td style="text-align:center">字符串</td>
<td style="text-align:center">整数</td>
</tr>
<tr>
<td style="text-align:center">字符串</td>
<td style="text-align:center">使用embstr编码的动态字符串</td>
</tr>
<tr>
<td style="text-align:center">列表</td>
<td style="text-align:center">压缩列表（ZipList）</td>
</tr>
<tr>
<td style="text-align:center">列表</td>
<td style="text-align:center">双向链表（LinkedList）</td>
</tr>
<tr>
<td style="text-align:center">Hash</td>
<td style="text-align:center">压缩列表</td>
</tr>
<tr>
<td style="text-align:center">Hash</td>
<td style="text-align:center">字典</td>
</tr>
<tr>
<td style="text-align:center">Set</td>
<td style="text-align:center">整数集合</td>
</tr>
<tr>
<td style="text-align:center">Set</td>
<td style="text-align:center">字典</td>
</tr>
<tr>
<td style="text-align:center">有序集合</td>
<td style="text-align:center">压缩列表</td>
</tr>
<tr>
<td style="text-align:center">有序集合</td>
<td style="text-align:center">跳跃表</td>
</tr>
</tbody>
</table>
<p>而对于字典来说，除了上面说的外，在Redis中还承担了很多其他的存储底层数据结构，之后可以慢慢说。</p>
<h4 id="字典的组成"><a href="#字典的组成" class="headerlink" title="字典的组成"></a>字典的组成</h4><p>先通过源码来更直接的感受一下字典的struct定义</p>
<pre><code>
// 单个节点结构定义
typedef struct dictEntry {
    void *key;  // key，也即是set k v的key
    union {
        void *val;
        uint64_t u64;
        int64_t s64;
        double d;
    } v;  // entry的值
    struct dictEntry *next; // 解决hash冲突，指向下一个entry
} dictEntry;
typedef struct dictht {
    dictEntry **table;  // 每个hash table中真正存放数据的table，二维数组
    unsigned long size;  // 当前ht的大小，也即总容量，一定是2的n
    unsigned long sizemask; // 永远为size-1的值，便于计算key在哪个table[]中
    unsigned long used;  // 已经使用的数量，也即是当前ht的key数量
} dictht;

// 定义字典
typedef struct dict {
    dictType *type; //字典的类型
    void *privdata; // 私有数据，和type相关联，用于实现不同字典的多态而设置
    dictht ht[2]; // 每个字典都有两个hash table，真正存储数据的实际字典，而正常情况下，只有ht[0]才会存储数据，ht[1]是在渐进式Rehash时用到的
    long rehashidx;  // 当前rehash对应的index，-1表示当前字典没有rehash
    unsigned long iterators; // 当前正在运行的迭代器数量
} dict;</code></pre>

<p>从dict的定义可以看到，其实类似于Java中的HashMap，只是这个Map是支持分布式的，而且在扩容缩容时，也要复杂一些。</p>
<ol>
<li><h5 id="字典的创建和插入"><a href="#字典的创建和插入" class="headerlink" title="字典的创建和插入"></a>字典的创建和插入</h5>字典在插入第一条数据时，其对应的字典都是已经创建好了的，也就是说他们的内存已经申请，对应的数据初始化也都已经完成了。在插入时，和HashMap的插入类似，根据key的hash值和字典的sizemask求与，得到一个index，也即是ht[0]所对应的table[index]；类比到HashMap，也就是找到对应的node（1.8版本），然后将对应的key value生成的entry放入对应的table中。此处和HashMap不一致的地方是，新加入的节点是放在链表的头部的，和HashMap不同（HashMap放在尾部），猜测此处也是为了快速完成数据的插入而设定的。不过观其源码，其实Redis在插入新的&lt;k,v&gt;时，也是检查了k是否已存在的，只是检查的时候，是放在一个独立的方法来做的，而该方法返回值是k应该存放的index值，所以在实际存放entry时，为了避免浪费时间，就把新的entry放到了头部。</li>
<li><h5 id="字典的更新"><a href="#字典的更新" class="headerlink" title="字典的更新"></a>字典的更新</h5>数据更新时，dict提供的一个api是dictReplace，先默认key不存在是新加操作，返回失败后，直接更新对应key的值，就完成了操作。</li>
<li><h5 id="字典的扩容"><a href="#字典的扩容" class="headerlink" title="字典的扩容"></a>字典的扩容</h5>当字典的容量达到一定比例时，将启动扩容。但好奇的一点时，Redis在判断是否需要对字典进行扩容时，负载因子竟然是0.1，低的让人不可相信，具体代码如下：<br><pre><code><br>int htNeedsResize(dict <em>dict) {<br>//判断是否需要对字典进行resize<br> long long size, used;<br> size = dictSlots(dict);// 字典总的大小<br> used = dictSize(dict); // 已经使用的大小<br> return (size &gt; DICT_HT_INITIAL_SIZE &amp;&amp; (used</em>100/size &lt; HASHTABLE_MIN_FILL)); //需要resize时，当前size已经是大于默认值4的当前负载因子小于默认最小的负载因子10，因为乘了100，也就是说0.1<br>}<br>void tryResizeHashTables(int dbid) {<br>// 判断redis对应db中的字典和存放带过期时间的key的字典是否需要resize<br> if (htNeedsResize(server.db[dbid].dict))<br>   dictResize(server.db[dbid].dict);<br> if (htNeedsResize(server.db[dbid].expires))<br>   dictResize(server.db[dbid].expires);<br>}<br></code></pre><br>在resize时，新的size必须大于已使用used的大小，同时是最小2的幂的值。只有size是2的幂时，sizemask才有意义！！</li>
<li><h5 id="渐进式Rehash"><a href="#渐进式Rehash" class="headerlink" title="渐进式Rehash"></a>渐进式Rehash</h5>在实际使用过程中，字典的扩容是伴随着rehash的，因为字典的size变了，同样的hash值，在计算index时，得到的值是不一样的，所以，在扩容时，新的size也是放到ht[1]中，而不是修改正在使用的ht[0]。</li>
</ol>
<p>在rehash过程中，新加入的key，会放到ht[1]的table中，同时会有后台任务（100ms执行一次）来执行rehash的操作，每次耗时1ms，将ht[0]中的key，逐步迁移到ht[1]中。每次都是按照table[rehashidx]的值来逐步处理。除了定时任务外，每次Redis在处理操作命令时，也会进行一次耗时1ms的rehash操作。</p>
<p>当ht[0]中的数据全部迁移到ht[1]后，就会将ht[0]=ht[1]，同时将ht[1]释放其内存空间。</p>
<p>在渐进式rehash过程中，读取的操作会分为两部分，先查询ht[0]，没有的话，再获取ht[1]</p>
<p>而至于rehash的图，其实网上很多，特别是《Redis设计与实现》中，画的很完美，就不拷贝了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/02/RabbitMQ和Kafaka/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="萧易">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/14055251?s=400&u=add42f8954fab30e11d0ecfdbc130b25da161103&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="萧易的技术沉淀">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/02/RabbitMQ和Kafaka/" itemprop="url">RabbitMQ和Kafaka</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-02T09:40:00+08:00">
                2019-06-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MQ/" itemprop="url" rel="index">
                    <span itemprop="name">MQ</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>  面试的时候，被问到技术选型是非常常见的一个问题了，但真的被问到的时候，怎么回答却是各种选择。<br>  我被问到过一次为什么选择RabbitMQ，而不选kafka或者rocketMQ。说实话，真的涉及到技术选型的时候，我更多的时候考虑的确实是学习成本。如果所有人都要花时间去学习新的MQ或者其他组件，那这个选型我觉得是失败的，即使每个人也许都学到了新的组件使用方式，但给项目带来的不确定性是一个大大的雷。<br>  可惜，如果面试的时候你这么回答，怕是哪个面试官都要给你打个大大的×。<br>  所以也来总结一下比较常用的RabbitMQ和Kafka这两个MQ</p>
<h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><p>  先说RabbitMQ，这个是我们项目中非常常用的MQ了。特别是转到金融部门后，作为可靠性很高的MQ，RabbitMQ被选中的频率就更高了。<br>  RabbitMQ是Erlang语言实现的一个基于AMQP协议的MQ组件。如下图所以：<br>  <img src="/2019/06/02/RabbitMQ和Kafaka/AMQP.png" alt="AMQP协议"><br>  由图可见，AMQP协议相比较于简单的队列，多了一个Exchange来做消息的中转；Producer也不会直接将消息投递到队列中，而是投递给exchange。同样的，AMQP规定了使用binding来绑定exchange和queue的关系。当消息到达Exchange之后，将消息路由给队列（如果找不到对应的绑定队列，则不路由）。<br>  AMQP提供了四种Exchange的类型</p>
<ol>
<li>Direct Exchange：根据route key进行匹配，将消息路由到binding key匹配route key的队列，也即是说route key和binding key必须严格匹配</li>
<li>Fanout Exchange：将消息发送给所有绑到该exchange的队列中，而不关心具体的route key</li>
<li>Topic Exchange：支持模糊匹配的直连exchange，通过*（单个字符）、#（不限个数）等通配符来模糊匹配，更加方便的来进行消息转发</li>
<li><p>Headers Exchange：不依赖route key和binding key来进行匹配，而是根据消息中的headers属性来进行匹配</p>
<p>而Kafka不一样，它并没有完整的按照AMQP的协议来实现，而是仿照AMQP，来实现了一套消息的收发机制。Kafka都是topic的方式，producer发送消息时，直接发送到topic，而每个topic会有多个partition，所以实际上，在发送消息时，会直接load balance到topic下面具体的partition中。每个partition中的消息都是有序的，但因为一个topic可以有多个partition，所以总体来说消息也是无序的。对于consumer来说，kafka引入了consumer group的概念，多个consumer可以组成一个组，同一个partition中的消息，只能被同一个consumer group中的一个consumer消费。</p>
<h4 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h4><p>在持久化方面，RabbitMQ和Kafka都是支持的。<br>对于RabbitMQ，持久化分为Exchange、queue和消息三种。</p>
</li>
<li><p>Exchange的持久化，是防止在broker（RabbitMQ Server实例）重启之后，exchange丢失的情况，如果不设置exchange的持久化，服务器重启后，exchange则不会自动复原，producer的消息发送也将受到影响。</p>
</li>
<li>Queue的持久化的作用同exchange是类似的，在声明队列时，将durable设为true即可。</li>
<li><p>消息的持久化，在发送消息时，可以选择将消息持久化，这样消息才会持久化到磁盘。通过MessageProperties.PERSISTENT_TEXT_PLAIN的方式来持久化消息。</p>
<p>如上可以看到，对于RabbitMQ来说，exchange、queue、消息三个核心都是可以选择持久化的，可靠性上就有很大的保障。而消息的持久化会有一定的延迟，RabbitMQ是每满1M或者隔25ms写一次盘,这也就意味着producer发送消息成功后，会有一定的丢消息的概率，当然这些是可配置的。</p>
<p>而对于Kafka来说，partition天然的支持持久化。为了提高持久化的效率，kafka记录的消息不做删除操作，只有顺序写，保证写盘时是顺序的，这样磁盘的IO效率提高很多。</p>
</li>
<li><p>每个partition都是append log，而保存的log默认保存7天，也支持配置。而为了避免日志爆盘，kafka提供了根据日志条数或者时间来删除日志，或者根据相同key对日志进行压缩的策略以供选择。</p>
</li>
<li>每条消息在落盘时，会分配一个offset，消费时，会依据此值来避免重复消费</li>
<li>producer在生产消息时，先把消息发送到partition的leader，然后由leader往slave节点同步；所以如果leader中的消息还没有来得及同步然后down掉，新选的leader是没有对应消息的，也即是消息丢失。</li>
</ol>
<h4 id="ACK机制"><a href="#ACK机制" class="headerlink" title="ACK机制"></a>ACK机制</h4><p>  而为了保证在生产和消费时的消息不丢失，RabbitMQ和Kafka都提供了ACK机制（kafka的consumer是根据offset来保证不丢消息）。<br>  先看RabbitMQ，RabbitMQ提供了两种方式来保证生产者的消息发送到broker：事务和发送确认</p>
<ol>
<li>事务。RabbitMQ的事务是基于AMQP协议来实现的。通过ConnectionFactory的Channel来完成具体的实现：channel.txSelect,channel.txCommit,channel.txRollback。在发送消息前，通过txSelect开启事务，然后通过basicPublish发送消息，txCommit提交事务，在发生异常时，可以通过txRollback回滚事务。在使用事务时，很明显的可以看到由于和rabbitmq多次进行交互，所以性能也会受到很大影响。</li>
<li><p>发送确认。这种方式相对来说要轻量级很多,也是通过Channel来实现。具体的确认方式有三种方式：<br>  2.1 channel.waitForConfirms 先通过confirmSelect打开发送确认，发送消息后，通过调用该方法可以阻塞式等待broker发送的确认消息。消息发送成功会返回true，反之返回false。可以设置等待超时时间，超时后会抛出Timeout异常<br>  2.2 channel.waitForConfirmsOrDie()批量确认消息发送结果。如果有发送失败的消息则会抛出异常。同样可以设置等待超时时间。<br>  2.3 ConfirmListener 通过实现该接口，来<strong>异步实现消息的结果确认</strong>;很明显，异步的意思就是生产者发送消息后就可以结束了，当有消息回调时，会根据消息的结果（ACK或NACK）来调用不同的方法，以完成不同的处理。</p>
<p>RabbitMQ的consumer通过ACK来确保消费者不会丢消息，或者消息处理失败时保证其他消费者会再次被消费。但默认情况下，Spring RabbitMQ的ack是自动ack，也就是说在有消费者获取一条消息后，就会认为消息被消费成功。所以一般会将autoAck设置为false，通过自己控制ack消息的发送时间点来保证消息被消费成功。当消息消费成功后，RabbitMQ会将消息删除<br>Kafka的ACK严格来说就只有producer支持。在发送消息时，kafka以供提供了三种方式来供选择</p>
<ul>
<li>发送完成即成功，也即是说不管下次是否持久化</li>
<li>master-slave模式，也即是消息需要partition的leader和slave都持久化成功，才算消息发送成功</li>
<li>master模式，也即是master的partition持久化成功即算发送成功。<br>通过设置request.required.acks来选择不同的模式；设置为0时也即是不关心具体投递结果；acks=1时需要master持久化后返回成功；acks=2时表示需要master和一个slave持久化成功；acks=-1表示需要master和所有的slave都持久化成功才算投递成功。<br>对于consumer来说，需要维护一个offset在zk中，来保存当前consumer消费的index，下次消费时，将拉取offset大于zk中的offset的消息。通过这种方式来保证consumer拿到的消息一定是消费成功的，消费不成功时，可以不更新zk中的offset。</li>
</ul>
</li>
</ol>
<h4 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性"></a>扩展性</h4><p>  其实看AMQP的消息分发就可以看到，RabbitMQ对于扩展性的支持是不够强的。即使是Master-slave的模式，消息也是只往同一个master的broker上发送，新加的节点也并不能起到很好的分流的作用。而Kafka不一样，每个topic都有自己的masterpartition，而整个集群没有严格意义上的master broker。通过将master的分散，来实现分流，降低单节点的压力。<br>  除此之外，RabbitMQ支持死信队列和延迟队列，也即是当消息消费失败或者超时后，可以将消息发送到配置好的死信队列中。依据此特性，可以使用RabbitMQ来实现一个分布式延迟队列的功能。同时RabbitMQ支持消息的优先级。这些Kafka都是不支持的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/29/线程池那些事-二/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="萧易">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/14055251?s=400&u=add42f8954fab30e11d0ecfdbc130b25da161103&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="萧易的技术沉淀">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/29/线程池那些事-二/" itemprop="url">线程池的那些事(二)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-29T20:48:00+08:00">
                2019-05-29
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JUC/" itemprop="url" rel="index">
                    <span itemprop="name">JUC</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>上篇说了ThreadPoolExecutor的构造函数，了解了一下如何才能更好的创建一个最适合自己的线程池，今天来看下线程池又是如何来具体执行任务的。<br>  在提交任务时，有两个方式：execute和submit。execute返回值是void，也就是不返回任何数据；submit是可以返回具体执行结果的方法，返回值类型是Future<t>；但看代码就会发现，submit中，最终调用的也是execute方法，所以今天就着重分析一下execute方法。<br>  上篇提到过，execute是把任务放入线程池中，而在这个过程中，线程池通过创建Worker的实例来完成实际工作线程的创建，核心部分如下：<br>  <pre><code>try {<br>   //将提交的任务作为worker的第一个任务，创建一个新的worker<br>    w = new Worker(firstTask);<br>    final Thread t = w.thread;<br>    if (t != null) {<br>    // 判断worker中的线程是否为空，该线程是构造方法中的threadFactory生成<br>        final ReentrantLock mainLock = this.mainLock;<br>        mainLock.lock();<br>        try {<br>            // 获取锁后，判断当前线程池的状态以及二次校验当前worker的线程状态是否存活<br>            int rs = runStateOf(ctl.get());<br>            if (rs &lt; SHUTDOWN ||<br>                (rs == SHUTDOWN &amp;&amp; firstTask == null)) {<br>                if (t.isAlive())<br>                    throw new IllegalThreadStateException();<br>                // 通过后，将worker加入set<br>                workers.add(w);<br>                int s = workers.size();<br>                if (s &gt; largestPoolSize)<br>                    largestPoolSize = s;<br>                workerAdded = true;<br>            }<br>        } finally {<br>            mainLock.unlock();<br>        }<br>       // 如果添加成功，则调用线程的start方法<br>        if (workerAdded) {<br>            t.start();<br>            workerStarted = true;<br>        }<br>    }<br>} finally {<br>    if (! workerStarted)<br>        addWorkerFailed(w);<br>}</code></pre><br>  Worker实现了Runnable接口，所以在添加成功，worker的线程调用start方法时，其实是调用了Worker的run方法，而看代码可以知道，最终调用的是runWorker，来看下具体逻辑：<br>  <pre><code>Thread wt = Thread.currentThread();<br>Runnable task = w.firstTask;<br>w.firstTask = null;<br>w.unlock();<br>boolean completedAbruptly = true;<br>try {<br>   // 任务不为空或者从blockqueue中获取到任务不为空，则执行任务，否则将会一直阻塞获取任务,也即是说此处可能会死等<br>    while (task != null || (task = getTask()) != null) {<br>        w.lock();<br>        // 执行时，先锁住当前worker<br>        if ((runStateAtLeast(ctl.get(), STOP) ||<br>             (Thread.interrupted() &amp;&amp;<br>              runStateAtLeast(ctl.get(), STOP))) &amp;&amp;<br>            !wt.isInterrupted())<br>            // 判断是否需中断当前线程（1.线程池被终止;2.线程池的线程被中断且线程池已终止且当前线程未中断）<br>            wt.interrupt();<br>        try {<br>           // 执行前检查，ThreadPoolExecutor中为空方法<br>            beforeExecute(wt, task);<br>            Throwable thrown = null;<br>            try {<br>                // 执行真正提交的Runnable的run方法<br>                task.run();<br>            } catch (RuntimeException x) {<br>                thrown = x; throw x;<br>            } catch (Error x) {<br>                thrown = x; throw x;<br>            } catch (Throwable x) {<br>                thrown = x; throw new Error(x);<br>            } finally {<br>                afterExecute(task, thrown);<br>            }<br>        } finally {<br>            task = null;<br>            w.completedTasks++;<br>            w.unlock();<br>        }<br>    }<br>    completedAbruptly = false;<br>} finally {<br>     // 处理线程的退出情况<br>    processWorkerExit(w, completedAbruptly);<br>}</code></pre><br>  看执行方法，可以发现，worker的线程会执行拿到的任务，而执行方式就是调用Runnable的run方法。如果拿不到任务，线程会通过getTask()这个方法，一直死循环的等待。getTask中会死循环从blockQueue中获取任务，但当线程的数量大于coreSize，且超过keepAlive的时间后，则不再继续死循环等待，而是返回一个null。当线程由于执行任务抛出异常而执行processWorkerExit方法时，completedAbruptly将会是true，表明是异常导致中断。<br>  来详细看下此处的处理<br>  <pre><code><br>  // 如果是突然完成，则通过cas，尝试将workers数量减一<br>if (completedAbruptly)<br>    decrementWorkerCount();<br>final ReentrantLock mainLock = this.mainLock;<br>mainLock.lock();<br>try {<br>   // 计算线程池总的完成任务的数量，然后移除当前的worker（对应的thread已经抛出异常终止，worker已经无法正常工作；另一种情况是，在线程池数量超过coreSize时，一样会终止任务，但这个时候，completedAbruptly会是false）<br>    completedTaskCount += w.completedTasks;<br>    workers.remove(w);<br>} finally {<br>    mainLock.unlock();<br>}<br>// 尝试终止线程池<br>tryTerminate();<br>int c = ctl.get();<br>if (runStateLessThan(c, STOP)) {<br>    if (!completedAbruptly) {<br>      // 如果是正常销毁线程，且当前线程数大于coreSize时，最终会直接返回<br>        int min = allowCoreThreadTimeOut ? 0 : corePoolSize;<br>        if (min == 0 &amp;&amp; ! workQueue.isEmpty())<br>            min = 1;<br>        if (workerCountOf(c) &gt;= min)<br>            return; // replacement not needed<br>    }<br>    // 如果走到此处，则会重新创建一个worker，由于没有指定firstTask，所以worker将尝试从队列中获取任务，而且可能会死等<br>    addWorker(null, false);<br>}</code></pre><br>  从上面的处理可以看到，在执行Runnable的run方法时，如果抛出了异常，线程池会再次创建一个新的worker来保证线程池的数量。<br>  以上就是线程池运行的原理的一个简单分析。其中getTask的这一步没有细讲，其实里面的内容也很多，比如线程是如何做才能保证在超过keepAlive的时间后，将大于coreSize的多余线程销毁。<br>  总的来说，线程池的内容就到此结束了。了解了原理，也就能更好的使用，规划线程池来达到最好的效果，比如实现自己的BlocedQueue，实现自己的RejectHandler等，也能避免一些踩坑的操作。</t></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/27/线程池的那些事/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="萧易">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/14055251?s=400&u=add42f8954fab30e11d0ecfdbc130b25da161103&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="萧易的技术沉淀">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/27/线程池的那些事/" itemprop="url">线程池的那些事(一)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-27T21:38:00+08:00">
                2019-05-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JUC/" itemprop="url" rel="index">
                    <span itemprop="name">JUC</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>  线程池其实写过Java的应该多少都会用到一些，而线程池的相关配置其实多多少少也会知道，今天就来看下线程池的相关配置和运行机制。<br>  编码过程中，大多数的线程池应该都是通过ThreadPoolExecutor来创建的，当然还有通过Executors来创建的，不过Executors内部也是通过ThreadPoolExecutor来创建，只是参数不同而已。下面来看下具体的构造方法<br>  <pre><code>public ThreadPoolExecutor(int corePoolSize, // 核心线程数量<br>                          int maximumPoolSize, // 最大线程数量<br>                          long keepAliveTime,  // 保持活跃的时间<br>                          TimeUnit unit, // 时间的单位<br>                          BlockingQueue<runnable> workQueue, // 线程数量达到核心线程数之后，用来存放新来任务的阻塞队列<br>                          ThreadFactory threadFactory, //生成线程的factory<br>                          // 当线程池满且线程数达到最大线程数量后，新来任务的拒绝处理handler<br>                          RejectedExecutionHandler handler) {<br>    if (corePoolSize &lt; 0 ||<br>        maximumPoolSize &lt;= 0 ||<br>        maximumPoolSize &lt; corePoolSize ||<br>        keepAliveTime &lt; 0)<br>        throw new IllegalArgumentException();<br>    if (workQueue == null || threadFactory == null || handler == null)<br>        throw new NullPointerException();<br>    this.corePoolSize = corePoolSize;<br>    this.maximumPoolSize = maximumPoolSize;<br>    this.workQueue = workQueue;<br>    this.keepAliveTime = unit.toNanos(keepAliveTime);<br>    this.threadFactory = threadFactory;<br>    this.handler = handler;<br>}</runnable></code></pre></p>
<p>  当一个任务提交到线程池后，会先检查线程数量是否达到corePoolSize，也即核心线程数量，如果没有达到，则通过threadFactory这一参数来创建新的线程放到线程池中，同时执行所提交的任务；<br>  当线程池的corePoolSize达到配置达到值时，新来的任务将尝试放入workQueue这一阻塞队列中，如果放入成功，则会检查是否需要新加线程，如果需要，则添加新的线程；如果入队失败，则执行reject，也即是调用handler的rejectedExecution。<br>  先说比较少关心的handler，RejectedExecutionHandler是个接口，只有一个方法rejectedExecution，就是在线程池满了之后拒绝任务的处理逻辑。在创建线程池时，可以自己实现该接口，以及对应的处理逻辑。Java也提供了四个已经实现的处理逻辑作为子类放在了ThreadPoolExecutor中，分别是：</p>
<ul>
<li>CallerRunsPolicy（会直接调用任务的run方法）</li>
<li>AbortPolicy（取消任务，也会抛出一个Reject的RuntimeExecpetion）</li>
<li>DiscardPolicy（放弃任务，不做任何处理）</li>
<li><p>DiscardOldestPolicy（抛弃最老的任务，从等待队列workerQueue中，拉取队首的任务，然后将新提交的任务放入队列）</p>
<p>四个提供的Handler中，ThreadPoolExecutor提供的默认的handler是AbortPolicy。<br>然后再来看threadFactory，ThreadFactory同样也是接口，只有一个newThread方法。在创建线程时，其实添加的是Worker这一实例，执行任务也同样是worker来执行。在创建线程时，最终执行的是new Worker；而在实例化Worker时，会通过threadFactory来创建一个真正执行任务的Thread。ThreadPoolExecutor中，默认的线程工厂是Executors中的DefaultThreadFactory，对应的newThread也相对比较简单，最终创建一个非守护线程，NORM_PRIORITY优先级的线程。<br>其他几个参数相对来说就比较常见且经常使用了，就直接跳过了。下次再来看线程池的运行机制。</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/25/Java线程状态变迁/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="萧易">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/14055251?s=400&u=add42f8954fab30e11d0ecfdbc130b25da161103&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="萧易的技术沉淀">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/25/Java线程状态变迁/" itemprop="url">Java线程状态变迁</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-25T14:50:00+08:00">
                2019-05-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JUC/" itemprop="url" rel="index">
                    <span itemprop="name">JUC</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>  想起之前面试时被问到的一个问题，也是因为这个问题，结果一面都挂了！！！问题也很简单，Java中线程有哪些状态？说实话，线程池用了不少，很少关心其具体状态，哪怕是看jstack时，也更多的是关心是否有死锁，很少关注具体状态。所以今天特地来看下Java中具体的线程状态。<br>  先看代码，Thread中，有个State的枚举，标注了Java线程的所有状态枚举值，如图所示：<br>  <img src="/2019/05/25/Java线程状态变迁/stateEnum.png" alt="状态枚举"><br>  不看不知道，一看吓一跳，竟然有六种之多，说实话是没有想到的，很多东西不知不觉间竟然都彻底遗漏了。<br>  顺序来看下所有的：<br>  NEW，顾名思义，就是线程初创，并没有进行执行；<br>  RUNNABLE，运行态，也即是线程正在运行中；<br>  BLOCKED，阻塞状态，正在等待一个锁资源；<br>  WAITING，等待状态，调用wait，park，join时，会进入等待状态；<br>  TIMED_WAITING，带时间的等待，一般是线程调用sleep方法时会进入该状态；<br> TERMINATED，终止状态，线程已经执行完成</p>
<p> 先来看简单的，简单写个代码，来看下NEW，RUNNABLE和TERMINATED<br> <img src="/2019/05/25/Java线程状态变迁/simpleCase.png" alt="简单示例"><br> 如图所示，当线程创建成功之后，还没有执行之前，状态是NEW；当调用start之后，线程进入RUNNABLE状态，也即运行中；但当子线程真正开始执行后，在sleep 10s的过程中，再来查看线程状态，就是TIMED_WAITING的状态；当子线程执行完成后，再来看线程状态，就是TERMINATED.<br> 只说这四种状态的话，整个状态的流转图如下：<br> <img src="/2019/05/25/Java线程状态变迁/simpleTrans.png" alt="简单流转"><br> 再来看BLOCKED和WAITING，还是先来通过代码来构造出这两个状态<br> 代码如下<br> <pre><code>System.out.println(“Main start”);<br>Object obj = new Object();<br>Thread thread1 = new Thread(() -&gt; {<br>    synchronized (obj) {<br>        try {<br>            // 在thread1拿到锁之后，sleep 2s便于thread2观察到blocked状态<br>            Thread.sleep(2000);<br>            // sleep之后，t1调用wait，这时，t1会进入wating状态<br>            obj.wait();<br>        } catch (InterruptedException e) {<br>            e.printStackTrace();<br>        }<br>        System.out.println(“t1 Im executing”);<br>    }<br>});</code></pre></p>
<p>Thread thread2 = new Thread(() -&gt; {<br>    synchronized (obj) {<br>        try {<br>        // 拿到锁后，sleep 1s便于观察t1的waiting状态<br>            Thread.sleep(1000);<br>        } catch (InterruptedException e) {<br>            e.printStackTrace();<br>        }<br>        System.out.println(“t2 Im executing”);<br>        obj.notifyAll();<br>    }<br>});</p>
<p>thread1.start();<br>thread2.start();<br>Thread.sleep(1000);<br>System.out.println(“t2 blocked “ + thread2.getState());<br>Thread.sleep(1500);<br>System.out.println(“t1 waiting “ + thread1.getState());</p>
<p>Thread.sleep(6000);<br>System.out.println(“Main end”);<br>  最终执行效果<br>  <img src="/2019/05/25/Java线程状态变迁/mixCase.png" alt="复杂流转"><br>  可以看到，在t1拿到锁且正在sleep2s时，t2的状态确实是BLOCKED，而t1 sleep结束后，调用wait，会释放锁，这时t2也就拿到了锁；t2拿到锁后，先sleep 1s，这时看t1的状态，正是WAITING状态，t2执行完后，调用notifyAll方法，t1又被唤醒，继续执行。<br>  综合阻塞和等待后，完整的状态流转图应该是：<br>   <img src="/2019/05/25/Java线程状态变迁/allStateTrans.png" alt="完整流转"><br>  从上面的分析中，也可以看到另外一个经常被问到的点，wait方法和sleep方法的区别：一个是进入了TIMED_WAITING，一个进入了WAITING状态，同时，sleep不会释放锁资源，而wait会释放持有的锁。<br>  除了wait/notify(notifyAll)外，还有其他方式来进行线程间通信，例如示例中同样用到的synchronized，Semaphore，ReentrantLock等</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/20/CyclicBarrier浅析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="萧易">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/14055251?s=400&u=add42f8954fab30e11d0ecfdbc130b25da161103&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="萧易的技术沉淀">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/20/CyclicBarrier浅析/" itemprop="url">CyclicBarrier浅析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-20T21:34:04+08:00">
                2019-05-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>面试阿里时，严格算来也就三次电面，结果有两次问到了一个JUC的工具类：CyclicBarrier。可惜，在实际工作中，确实没有用到过这个类，更别说原理之类的了，虽然第一次问到的实话简单看了下，但第二次被问到的时候还是很懵逼。今天就来简单看下这个类。<br>  先看作用，CyclicBarrier类主要是用来做并发控制，但作用感觉像是和CountDownLatch正好反过来一样。CountDownLatch是可以使主线程处在一个等待状态，直到子线程任务完成。而CyclicBarrier则是控制子线程在同一个时刻执行。来看个例子如图：<br>  <img src="/2019/05/20/CyclicBarrier浅析/CycliBarrier示例.png" alt="执行示例"><br>  从上面的例子可以看到，五个线程Sleep了完全不同的五个时间，但最后开始执行的时间却是一样的，这也是CyclicBarrier的主要功能，可以控制子线程在同一个时刻执行，而不用关心子线程具体在什么时候才拿到执行资源。<br>  一样的，来看下原理。<br>  CyclicBarrier通过ReentrantLock和Condition来实现并发的控制，在new一个CyclicBarrier实例时，需要指定数量，具体看构造方法：<br>  <pre><code>public CyclicBarrier(int parties, Runnable barrierAction) {<br>    if (parties &lt;= 0) throw new IllegalArgumentException();<br>    // barrier的具体数量，也即是要执行的总的线程（或者任务）数量<br>    this.parties = parties;<br>    // 等待的数量<br>    this.count = parties;<br>    // command，实现了Runnable的一个类，会在所有线程到达后，由最后到达的线程触发一次执行，调用run方法<br>    this.barrierCommand = barrierAction;<br>}</code></pre><br>  看了构造方法后，再来看具体的执行方法dowait，这个方法中实现了真正的等待，await和await(long, TimeUinit)都是调用的dowait方法：<br>  <pre><code>final ReentrantLock lock = this.lock;<br>// 先获取锁，这样的话，就保证只会有一个子线程来执行command<br>lock.lock();<br>try {<br>    final Generation g = generation;<br>    if (g.broken)<br>        // 每次执行前都判断是否已经中断，中断则抛出异常<br>        throw new BrokenBarrierException();<br>    if (Thread.interrupted()) {<br>        breakBarrier();<br>        throw new InterruptedException();<br>    }</code></pre></p>
<pre><code>int index = --count;
if (index == 0) {  
    // 等待线程数量已经为0，也即是其他线程已经进度等待队列，则执行command，执行成功后，唤醒所有等待线程，重置count，generation
    boolean ranAction = false;
    try {
        final Runnable command = barrierCommand;
        if (command != null)
            command.run();
        ranAction = true;
        nextGeneration();
        return 0;
    } finally {
        if (!ranAction)
            // 如果执行失败，同样唤醒所有线程
            breakBarrier();
    }
}

// loop until tripped, broken, interrupted, or timed out
for (;;) {
    try {
        if (!timed)
            // 在循环中进行等待，调用AQS的await方法，此方法中会将当前线程入队，然后检查node是否在队列中，在则返回，也即保证所有子线程（最后一个除外）会进入等待队列
            trip.await();
        else if (nanos &gt; 0L)
            nanos = trip.awaitNanos(nanos);
    } catch (InterruptedException ie) {
        if (g == generation &amp;&amp; ! g.broken) {
            breakBarrier();
            throw ie;
        } else {
            // We&apos;re about to finish waiting even if we had not
            // been interrupted, so this interrupt is deemed to
            // &quot;belong&quot; to subsequent execution.
            Thread.currentThread().interrupt();
        }
    }

    if (g.broken)
        throw new BrokenBarrierException();

    if (g != generation)
        return index;

    if (timed &amp;&amp; nanos &lt;= 0L) {
        breakBarrier();
        throw new TimeoutException();
    }
}
</code></pre><p>} finally {<br>    // 在进行其他判断后，如果barrier还是处于正常状态，则将当前线程持有的锁释放，其他线程将依次获取锁并进入等待队列<br>    lock.unlock();<br>}</p>
<p>  核心的await方法，一样还是依赖AQS，而只看CyclicBarrier的话，在依次将子线程放入等待队列后，就会立马释放锁，然后等最后一个执行dowait的方法，将所有等待线程唤醒。<br>  而对于AQS的依赖，主要是ConditionObject，这个是AQS提供的一个相对比较独立的功能，也提供了入队，唤醒等方法。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/18/Semaphore解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="萧易">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/14055251?s=400&u=add42f8954fab30e11d0ecfdbc130b25da161103&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="萧易的技术沉淀">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/18/Semaphore解析/" itemprop="url">Semaphore解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-18T21:27:00+08:00">
                2019-05-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JUC/" itemprop="url" rel="index">
                    <span itemprop="name">JUC</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>  在将CountDownLatch的时候，提到了Semaphore这一工具类，也是通过实现AQS的共享锁来实现线程间的通信，说实话之前还真没有怎么用过信号量这一机制，正好今天借这个机会来一探Semaphore。<br>  还是简单写个示例，来看下Semaphore的作用，实现一个Runnable，在运行前先进行tryAccquire，然后再执行，最后执行效果：<br>  <img src="/2019/05/18/Semaphore解析/semaphoreTest.png" alt="执行结果"><br>  通过执行结果来看，在初始化Semaphore为1时，多个线程也是会出现排队等待的情况，拿到permit之后才会执行对应的逻辑,在release锁资源之后，其他线程按照顺序拿到锁资源后，才继续进行后续操作。从上面看，是不是感觉和ReentrantLock极度相似！但其实不然，因为Semaphore初始化时，permits也就是AQS的state初始化成了1，所以会感觉和ReentrantLock很像，当把state设置会2时会发现，同时会有两个线程执行，设置为3时，将不会再有等待！！换个角度来看，MQ！！！<br>  来看下具体的差别：<br>  在调用acquire(1)时，会调用AQS的方法，代码如下：<br>  <pre><code>public final void acquireSharedInterruptibly(int arg)<br>            throws InterruptedException {<br>        if (Thread.interrupted())<br>            throw new InterruptedException();<br>        if (tryAcquireShared(arg) &lt; 0)<br>        // 调用具体实现类的acquire，结果小于0则等待<br>            doAcquireSharedInterruptibly(arg);<br>}</code></pre><br>  从上可以看到，通过调用Semaphore中实现的tryAcquireShared来获取permit，最终会返回一个int值，如果值小于0，表示锁资源已经被抢占完，后到的线程就需要等待。先看申请锁的实现：<br>  <pre><code>for (;;) {<br>  // 死循环来计算remaining，直到remaining小于0(也即锁被抢占完)，或者占有一个锁<br>    int available = getState();<br>    int remaining = available - acquires;<br>    if (remaining &lt; 0 ||<br>        compareAndSetState(available, remaining))<br>        return remaining;<br>}</code></pre><br>  所以申请锁的实现中，最终肯定会返回一个int值，而这个值其实就是当前的state值减去当前线程在申请锁时所输入的值。<br>  Semaphore的等待处理方式和CountDownLatch是一样的，都是以共享锁的方式进入等待队列，然后循环来获取。此处就不再赘述了！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/18/CountDownLatch解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="萧易">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/14055251?s=400&u=add42f8954fab30e11d0ecfdbc130b25da161103&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="萧易的技术沉淀">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/18/CountDownLatch解析/" itemprop="url">CountDownLatch解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-18T21:18:00+08:00">
                2019-05-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JUC/" itemprop="url" rel="index">
                    <span itemprop="name">JUC</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>之前讲了一下AQS的独占锁，包括公平锁和非公平锁，这次来看看共享锁的内容。<br>  在JUC中，实现共享锁的有两个类：CountDownLatch和Semaphore。今天先来看下比较常用的CountDownLatch。记得第一次用的时候，还是在导师来告诉我可以用这么一个工具类来做一个并发的控制。<br>  CountDownLatch的作用就是等待子线程的执行完成，然后主线程再继续执行。语言总是苍白的，直接上示例。<br>  简单实现一个Runnable,代码如下：<br>  <pre><code>System.out.println(“Prepare to execute task”);<br>  while (true) {<br>    System.out.println(“I’m working”);<br>    try {<br>      Thread.sleep(1000);<br>    } catch (InterruptedException e) {<br>      e.printStackTrace();<br>    }<br>    break;<br>  }<br>  System.out.println(“End execute task”);</code></pre><br>   代码很简单，就是在子线程中Sleep 1s，看下执行效果：</p>
<p><img src="/2019/05/18/CountDownLatch解析/pasted-1.png" alt="没有使用CountDownLatch时的运行结果"><br> 可以看到，在启动线程后，主线程就直接结束了，而子线程则是在Sleep结束之后终止执行。其实这个时候，而CountDownLatch的作用就是使得主线程可以等待子线程执行结束之后再结束。<br> 再实现一个使用了CountDownLatch的Runnable，代码如下：<br> <pre><code>public CountDownLatchRunnable(CountDownLatch countDownLatch) {<br>    this.countDownLatch = countDownLatch;<br>}<br>@Override<br>public void run() {<br>    System.out.println(“Prepare to execute task”);<br>    while (true) {<br>        System.out.println(“I’m working”);<br>        try {<br>            Thread.sleep(1000);<br>        } catch (InterruptedException e) {<br>            e.printStackTrace();<br>        }<br>        break;<br>    }<br>    System.out.println(“End execute task”);<br>    // 区别就在于，增加了一个countdownLatch，在执行任务完成后，进行countDown<br>    countDownLatch.countDown();<br>}</code></pre><br> 再来看执行效果：</p>
<p><img src="/2019/05/18/CountDownLatch解析/pasted-2.png" alt="使用CountDownLatch时的运行结果"><br>可以看到主线程是在子线程执行完成后，主线程才执行完成。而区别相较没有CountDownLatch的，就是多了一个CountDownLatch的await方法调用，来看下该方法的具体作用。<br>在使用CountDownLatch时，可以看到在创建对象实例时，需要传入一个int，这个值最终会设置为AQS的state这一变量的值，代码如下：</p>
<pre><code>public CountDownLatch(int count) {
    if (count < 0) throw new IllegalArgumentException("count < 0");
    this.sync = new Sync(count);
}
Sync(int count) {
     setState(count);
}</code></pre>
  而之前将独占锁的时候提到过，当AQS的state为0时表示锁没有被使抢占，而每个线程在抢占锁时，也可以指定一个值X，抢占到后，state将增加X；同样，线程释放锁时，state也会减去X。
  而创建对象时，将state置为一个值，那CountDownLatchRunnable的countDown自然也就是去减去state了，而await自然也就是等待state等于0，也就表明主线程可以继续往下执行了。而共享的意思自然也就是说任何子线程只要持有countDownLatch的实例，就可以进行countDown的操作，类似CountDownLatchRunnable中所做的那样。
  通过上面的分析，可以看到在初始化state之后，对于共享锁来说，主要的方法应该是有两个：release（countdown）持有的锁资源，循环等待的await。
  先来看countdown，具体的实现代码如下：
<pre><code>for (;;) {
    // 通过死循环的方式，将state减一
    int c = getState();
    if (c == 0)
        return false;
    int nextc = c-1;
    if (compareAndSetState(c, nextc))
    // 返回减一之后state是否为0的判断结果
        return nextc == 0;
}</code></pre>
在将state减一后，会判断state是否被减为了0，如果是的话，则会触发唤醒等待线程的操作：
<pre><code>if (tryReleaseShared(arg)) {
   // 如果state等于0，将会唤醒等待线程
     doReleaseShared();
     return true;
 }
 return false;</code></pre>
 其实对于countdownlatch的使用场景来说，只有主线程调用await才会进行等待队列，所以此处唤醒等待线程也就是唤醒主线程。来看下代码：
 <pre><code>for (;;) {
    Node h = head;
    if (h != null && h != tail) {
    // 如果等待的head不为空，则将head唤醒
        int ws = h.waitStatus;
        if (ws == Node.SIGNAL) {
            if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
                continue;          
            unparkSuccessor的调用，调用后，h和head将不会相等(h);
        }
        else if (ws == 0 &&
                 !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
            continue;               
    }
    if (h == head)  
    // 此处的判断是针对主线程的等待循环，会修改head
        break;
}</code></pre>
在通知等待线程后，相对来说也就是主线程被唤醒，将继续往下执行，而这又牵扯到await方法，具体实现代码如下：
<pre><code>if (tryAcquireShared(arg) < 0)
  // 在调用await方法时，会先判断state是否为0，为0则不做任何处理，不为0，则将执行 doAcquireSharedInterruptibly
            doAcquireSharedInterruptibly(arg);</code></pre>

<p> 入队的代码如下：<br> <pre><code>// 当前线程加入等待队列<br>final Node node = addWaiter(Node.SHARED);<br>boolean failed = true;<br>try {<br>    for (;;) {<br>    // 死循环查看state是否为0<br>        final Node p = node.predecessor();<br>        if (p == head) {<br>            int r = tryAcquireShared(arg);<br>            if (r &gt;= 0) {<br>            // 如果state为0，则将将等待节点置为head，也就是持有锁，可以继续进行后续操作<br>                setHeadAndPropagate(node, r);<br>                p.next = null; // help GC<br>                failed = false;<br>                return;<br>            }<br>        }<br>        if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>            parkAndCheckInterrupt())<br>            throw new InterruptedException();<br>    }<br>} finally {<br>    if (failed)<br>        cancelAcquire(node);<br>}</code></pre></p>
<p>  所以从上可以看出，针对CountDownLatch来说，真正的等待线程只有调用了await方法的线程，而其他子线程则是只负责对state减一。<br>  同样的，如果编码bug，导致state不被减为0，await将会一直死循环等待。<br>  当然调用 await(long timeout, TimeUnit unit)可以解决死等的问题，这个也就是针对等待线程加上了一个等待时长，超时将终止等待。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/11/AQS浅析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="萧易">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/14055251?s=400&u=add42f8954fab30e11d0ecfdbc130b25da161103&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="萧易的技术沉淀">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/11/AQS浅析/" itemprop="url">AQS浅析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-11T21:30:00+08:00">
                2019-05-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JUC/" itemprop="url" rel="index">
                    <span itemprop="name">JUC</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>上一篇看了一下公平锁和非公平锁在代码上的差别，其实看到主要的逻辑很多都是在AQS中实现的，所以今天再来看下AQS。<br>  AbstractQueuedSynchronizer，简称AQS，继承了AbstractOwnableSynchronizer这一抽象类，AbstractOwnableSynchronizer主要是管理当前持有锁的线程。<br>  AQS中，有一个volatile变量，state，表明了当前锁的状态，为0时表明锁处于空闲状态，也即是没有被任何线程持有，所以在ReentrantLock中，在获取锁时，都是先判断state是否等于0。<br>  除此之外，AQS还维护了一个双向链表，来存放等待队列，如下：<br>  <pre><code><br>       +——+  prev +—–+       +—–+<br>head |      | &lt;—- |     | &lt;—- |     |  tail<br>     +——+       +—–+       +—–+<br>     </code></pre></p>
<p>  简单来说，在线程来请求锁时，如果锁被其他线程持有且不是当前请求锁的线程，则将线程入队，然后循环请求锁。<br>  对于公平锁和非公平锁，入队的操作都是一致的，具体的代码如下：</p>
<p>  <pre><code><br>  final long deadline = System.nanoTime() + nanosTimeout;<br>  // 先创建一个Node，以独占的方式存放当前线程，在addWaiter中，如果tail不为空，则将新建的node放到队尾，如果tail为空，则在循环中，通过CAS将node设置为head或者tail<br>  final Node node = addWaiter(Node.EXCLUSIVE);<br>  boolean failed = true;<br>  try {<br>    for (;;) {<br>     final Node p = node.predecessor();<br>     if (p == head &amp;&amp; tryAcquire(arg)) {<br>     // 如果节点的preNode是head，且当前节点获取到了锁，则将当前节点置为head，同时返回true，此处的tryAcquire就是上一篇中的Fair和NonFair的实现<br>       setHead(node);<br>       p.next = null; // 这一步其实就是将preNode置为一个无人引用且不引用他人的状态，利于GC<br>       failed = false;<br>       return true;<br>     }<br>     nanosTimeout = deadline - System.nanoTime();<br>     if (nanosTimeout &lt;= 0L) {<br>        // 判断是否等待超时，超时则返回false，也即请求锁失败<br>        return false;<br>     }<br>    if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>       nanosTimeout &gt; spinForTimeoutThreshold) ｛<br>       // 在申请锁失败后，判断是否需要进行等待，主要是通过判断preNode是否已经获取到锁等待signal，如果是则等待，不是则不等待，等待1000ns<br>        LockSupport.parkNanos(this,nanosTimeout);<br>     }<br>     if (Thread.interrupted())<br>       throw new InterruptedException();<br>    }<br>  } finally {<br>    if (failed)<br>    // 如果申请锁失败，则将对应node的状态置为cancel<br>       cancelAcquire(node);<br>  }<br>  </code></pre><br>  其实从上面的代码可以看到，在入队后，非公平锁的等待线程也会按照顺序依次来获取锁（强制条件，preNode==head）！！</p>
<p>  以上，对于请求独占锁，AQS就这些内容了。先请求锁，请求不到则入队，在队列中依次来获取锁，知道获取到或者等待超时结束。<br>  当然还有release，对于ReentrantLock，release其实没太有太复杂的东西，就是将持有的锁释放，但由于释放的步骤是先将锁的状态置为0，独占线程置为空，然后再唤醒等待中的head；当然这个过程也给了其他线程机会，也就有了公平锁和非公平锁的区别。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="https://avatars3.githubusercontent.com/u/14055251?s=400&u=add42f8954fab30e11d0ecfdbc130b25da161103&v=4" alt="萧易">
            
              <p class="site-author-name" itemprop="name">萧易</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">萧易</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
